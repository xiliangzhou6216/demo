

## ES6 类 语法糖


```js
class Cat {
    say() {
        console.log(111);
    }
}
```
Object.defineProperty()构造函数上添加属性


```js

function Cat() {}
Object.defineProperty(Cat.prototype, "say", {
    value: function() { 
      console.log(111)
    },
    enumerable: false,
    configurable: true,
    writable: true
});

```

##  ES6继承方式

- class 可以通过extends关键字实现继承，继承父类的所有属性和方法,不管是公有私有还是静态；
- 子类constructor里调用super()（父类构造函数）实现 实例属性和方法的继承；


> class中 声明是变量形式 是方法，会挂载到原型上，否则挂载到自身实例上

```js

class B extends A {
  constructor() {
    console.log(new.target.name);
  }
}

// 等同于
class B extends A {
  constructor(...args) {
    super(...args);
  }
}


new A() // A
new B() // B
```


>ES6 中子类没有自己的this，必须执行super()，子类的this是从父类继承的；所以继承先有父类实例，再通过在子类的构造函数修改this指向

**super** 关键字


- 可以作为函数使用 super()代表父类的构造函数；相当与在子类构造函数中 A.prototype.constructor.call(this)
- 作为对象使用；在普通方法中，super指向是父类的原型对象，在静态方法中，super指向是父类


```js
// super注意使用方式
// 使用super的时候，必须显式指定是作为函数、还是作为对象使用（就是super后边必须跟东西），否则会报错
class A{
  static  type=11111
  constructor(){
    this.type=22222
  }
  type(){

  }
}

class B extends A{
  constructor(){
    super()
  }
  p(){
    console.log(super.type)
  }
  static s(){
    console.log(super.type)
  }
}

B.s() //  11111
(new B()).p() // type fun

```


### 类的继承的实现模式

```js

class A {
}

class B {
}

// B 的实例继承 A 的实例
Object.setPrototypeOf(B.prototype, A.prototype);

// B 继承 A 的静态属性
Object.setPrototypeOf(B, A);

const b = new B();

```

##  ES5和ES6的区别 

- ES6 中的子类实例可以继承原生构造函数实例的内部属性，而在 ES5 中做不到
- super() 与 Parent.call(this) 是不同的   先后顺序不一样
- ES6 中子类会继承父类的所有属性和方法（这里属性其实就是原型对象+静态属性+实例自身属性）  

本质

```js
class A extends Aarry{
  constructor(){
    super()
  }
}
```


##  ES5继承方式

- 利用借用构造函数实现 实例属性和方法的继承 
- 利用原型链继承实现 共享的原型属性和方法的继承 

###  原型链继承

1. 原型上引用类型的属性值会被所有子实例共享
2. 父级不能传参数给子级 

```js
function Parent(){
  this.colors=[1,2,1]
}

function Child(){
  
}
Child.prototype=new Child()

var child1 =new Child()

```

###  构造函数继承

1. 无法共享原型对象上的属性和方法

```js
function Parent () {
    this.names = ['kevin', 'daisy'];
}

function Child () {
    Parent.call(this);
}

var child = new Child();
```

### 原型式继承

本质 把对象挂在原型上

1. 原型上引用类型的属性值会被所有子实例共享

```js

// Object.create()原理
function createObj(obj){
  function f(){}
  f.prototype=obj
  return new f()
} 


function Parent () {
    this.names = ['kevin', 'daisy'];
}

var child=Object.create(Parent);
```



###  寄生组合式继承

本质  原型链继承+构造函数继承

>这种方式的高效率体现它只调用了一次 Parent 构造函数，并且因此避免了在 Parent.prototype 上面创建不必要的、多余的属性。与此同时，原型链还能保持不变；因此，还能够正常使用 instanceof 和 isPrototypeOf。

```js
function Parent () {
    this.names = ['kevin', 'daisy'];
}

Parent.prototype.say=function(){

}

function Child () {
    Parent.apply(this,arguments);
}

// 修改子类原型
function prototype(child, parent){
  const prototype =Object.create(parent.prototype)
  prototype.constructor=child
  child.prototype=prototype
}
prototype(Parent,Child)
Child.prototype.kk=function (){

}

var child1 = new Child();
```