

### prototype

每个函数都有一个 prototype 属性


```js
 function Person(){}

 Person.prototype // 实例原型

```


###  __proto__

每一个js对象一个属性 __proto__  指向对象的原型

```js
 function Person(){}
 const person=new Person()

 person.__proto__ === Person.prototype // true

```


### constructor

每一个原型都有一个constructor属性指向关联的构造函数

```js
function Person() {

}
console.log(Person === Person.prototype.constructor); // true

```

person没这个constructor属性,但是这个属性也可以从原型上获取

```js
person.constructor === Person.prototype.constructor // true

```

#### getPrototypeOf

获取对象的原型

```js
obj.__proto__=== Object.getPrototypeOf(obj)
```

#### setPrototypeOf 

设置对象的原型

>Object.setPrototypeOf(obj, prototype)

> prototype;该对象的新原型

```js
let o={
    a(){
        return 'xiliang'
    }
}

let obj=Object.setPrototypeOf({}, o)

Object.getPrototypeOf(obj) // 在原型上 {a: ƒ a()}

```


####  create()

设置对象的原型和自身属性


>Object.create(proto，[propertiesObject])

>propertiesObject;将为新创建的对象添加指定的属性值和对应的属性描述符

```js
// 省略了的属性特性默认为false,所以属性p是不可写,不可枚举,不可配置的
Object.create({}, { p: { value: 42 } }) // {p:42}


//创建一个可写的,可枚举的,可配置的属性p
o = Object.create({}, {
  p: {
    value: 42,
    writable: true,
    enumerable: true,
    configurable: true
  }
}); // {p:42}

```


####  注意


**创建对象方式**

- new Object() 
- {}
- Object.create(null)
- Object.setPrototypeOf({},null)


```js
Function.__proto__ === Function.prototype // true
```
