[TOC]


# 面向对象 

- 抽象
- 继承
- 封装
- 多态

## 模式

### 创建型
- 工厂模式(工厂方法模式、抽象工厂模式、简单工厂模式)、建造者模式、单例模式

### 结构型模式
- 重要: 代理模式、桥接模式、装饰器模式、适配器模式

### 行为型
- 重要: 观察者模式、模版方法模式、策略模式、职责链模式、迭代器模式、状态模式


## 1. 工厂模式
****

- 简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例

### 类图
![avatar](http://wsk-mweb.oss-cn-hangzhou.aliyuncs.com/2020/01/27/15801210902317.jpg)
![69feafb9e3e08bcc2a5ae4c3a6f89de.png](https://i.loli.net/2021/04/26/7rbRPsLkSYyaOwu.png)

### 代码

```js
abstract class Coffee {
    constructor(public name: string) {

    }
}
class AmericanoCoffee extends Coffee {
    constructor(public name: string) {
        super(name);
    }
}
class LatteCoffee extends Coffee {
    constructor(public name: string) {
        super(name);
    }
}
class CappuccinoCoffee extends Coffee {
    constructor(public name: string) {
        super(name);
    }
}

class Café {
    static order(name: string) {
        switch (name) {
            case 'Americano':
                return new AmericanoCoffee('美式咖啡');
            case 'Latte':
                return new LatteCoffee('拿铁咖啡');
            case 'Cappuccino':
                return new LatteCoffee('卡布奇诺');
            default:
                return null;
        }
    }
}
console.log(Café.order('Americano'));
console.log(Café.order('Latte'));
console.log(Café.order('Cappuccino'));
```

### 前端应用场景

- jQuery

```js
class jQuery{
    constructor(selector){
        let elements = Array.from(document.querySelectorAll(selector));
        let length = elements?elements.length:0;
        for(let i=0;i<length;i++){
            this[i]=elements[i];
        }
        this.length = length;
    }
    html(html){
        if(html){
           this[0].innerHTML=html;
        }else{
          return this[0].innerHTML;
        }
    }
}
window.$ = function(selector){
   return new jQuery(selector);
}

```
## 2.单例模式

>保证一个类仅有一个实例，并提供了一个访问它的全局访问点，这样的模式就叫单例模式

```js
// 也可以写在构造函数的函数体里
class SingleDog {
    construtor(){

    }
    static getInstance(){
        if(!SingleDog.Instance){
            SingleDog.Instance=new  SingleDog()·1
        }
        return SingleDog.Instance
    }

}

function SingleDog(){

}
SingleDog.prototype.hello=function(){
    console.log(123)

}
// 利用闭包实现
SingleDog.getInstance=(function (){
    let Instance=null
    return function (){
        if(!Instance){
            Instance=new  SingleDog() 
        }
        return Instance
    }
}())

```
## 3. 适配器模式
> 适配器模式通过把一个类的接口变换成客户端所期待的另一种接口

兼容接口就是一把梭——适配器的业务场景

1. fenth

```js
 class Http{
      // get方法
      static get(url,data){
          return new Promise(( resolve,reject )=>{ 
            fetch(url+'?'+this.handleParams(data),{
              method: 'GET'
            })
            .then(response =>response.json())
            .then(res=>{
              resolve(res)
            })
            .catch(err=>{
              reject(err)
            })
          })
      }
      // post方法，data以object形式传入
      static post(url,data){
          return new Promise(( resolve,reject )=>{ 
            fetch(url,{
              // body:JSON.stringify(data),
              body:this.handleParams(data),
              method: 'POST', 
              headers:{
                // 'Content-type':'application/json;charset=UTF-8'  // JSON数据
                Accept: 'application/json',
                'Content-Type': 'application/x-www-form-urlencoded'  // 指定提交方式为表单提交
              }
            })
            .then(response =>response.json())
            .then(res=>{
              resolve(res)
            })
            .catch(err=>{
              reject(err)
            })
          })
      }
      // body请求体的格式化方法
      static handleParams(obj){
          var o=Object.keys(obj)
          var str=''
          // console.log(o)
          for(const item in o){
                str+=o[item]+'='+obj[o[item]]+(o.length-1!=item?'&':'')
          }
          return str
        }
      }

 async function Ajax() {
    const URL = "https://api.github.com/users/ruanyf"
    // 定义post入参
    const params = {foo:'bar',loop:'121'}
    const result= await  Http.get(URL,params)
    console.log(result,11111)
 }
 Ajax()

```
2. 原生xhr

```js
 /**   
   * @description  Ajax请求 包含 get post 
   * @param {String} type 请求类型
   * @param {String} url 请求url
   * @param {Object} data 请求数据
   * @param {Function} success 请求成功函数
   * @param {Function} error 请求失败函数
   * @return { String } 无
   */
   Ajax('get','https://api.github.com/users/ruanyf',{foo:'bar',loop:'121'},function(data){
    console.log(data,111111111)
  },function(err){
    console.log(err,54444444444)
  })
   
  
 
   function Ajax(type,url,data,success,error) {
      if(success&&typeof success !='function' ){
        throw new Error(success+'is not function')
      }
      if(error&&typeof error !='function' ){
        throw new Error(error+'is not function')
      }
      var type =type.toLocaleUpperCase()
      if(window.XMLHttpRequest){
         //Firefox、 Opera、 IE7 和其它浏览器使用本地 JavaScript 对象
        var xhr = new XMLHttpRequest()
      }else{
         //IE 5 和 IE 6 使用 ActiveX 控件
        var xhr =new ActiveXObject("Microsoft.XMLHTTP");
      }

      //XMLHttpRequest.send() 方法接受一个可选的参数，其作为请求主体；如果请求方法是 GET 或者 HEAD，则应将请求主体设置为 null
      if(type==='GET'){
        xhr.open(type,url+'?'+handleParams(data))
        xhr.send(null)
      }

      if(type==='POST'){
        // 如果需要像 html 表单那样 POST 数据，使用 setRequestHeader() 来添加 http 头。
        // xhr.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
        // xhr.send('foo=bar&lorem=ipsum')
        xhr.open(type,url)
        xhr.setRequestHeader("Content-type", "application/json;charset=UTF-8");
        xhr.send(data)
      }

      xhr.onreadystatechange=function(){  // 当readystate状态变化，callback函数会被调用   这个方法只能用异步的XMLHttpRequest对象
        if (xhr.status===200&&xhr.readyState===XMLHttpRequest.DONE) {
          success?.(xhr.response)
        }else{
          error?.(xhr.response)   
        }
      }

      // 处理请求数据
      function handleParams(obj){
        var o=Object.keys(obj)
        var str=''
        for(var item in o){
              str+=o[item]+'='+obj[o[item]]+(o.length-1!=item?'&':'')
        }
        return str
      }
      
   }

```
